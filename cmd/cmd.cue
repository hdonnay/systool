package cmd

import (
	"strings"
)

run: {
	_kind: string
	fragment: string
}

qstring: {
	value: string
	output: "'\(value)'"
}
dstring: {
	value: string
	output: "\"\(value)\""
}

cmdarg: string | { output: string }

cmd: run & {
	_kind: "cmd"
	exe: string
	argv: [...cmdarg]
	fragment: "\(exe) \(_compiled)"

	_compiled = strings.Join([ (x&string)|x.output for x in argv ], " ")
}

list: run & {
	_kind: "list"
	sub: [...run]
	fragment: strings.Join([ x.fragment for x in sub ], "\n")
}

ctl: run & {
	_kind: "ctl"
	test: string | run
	body: run | [...run]
	ctl: {
		start: string
		then: string
		end: string
	}
	fragment: "\(ctl.start) \(_test);\(ctl.then)\n\(_inner)\n\(ctl.end)"
	
	_test = (test&string) | test.fragment
	_inner = (body.fragment&string) | (list&{sub: body}).fragment&string
}

cond: run & ctl & {
	ctl: start: "if"
	ctl: then: "then"
	ctl: end: "fi"
}

test: cmd & {
	exe: "test"
	test: cmdarg | [...cmdarg]
	argv: [ (x&string)|x.output for x in _test ]

	_test: [ (test&cmdarg) ] | test
}

while: run & ctl & {
	ctl: start: "while"
	ctl: then: "do"
	ctl: end: "done"
}

switch: run & {
	_kind: "switch"
	test: *"" | cmdarg
	case: [string]: [ ...run ]
	fragment: "case \((test&string)|test.output) in\n" +
		strings.Join(["\(pat))\n\( strings.Join([v.fragment for v in body], "\n") )\n;;" for pat, body in case], "\n") +
		"\nesac"
}

msg: cmd & {
	msg: [...string]|string
	exe: "printf"
	argv: [
		qstring&{value:": %s\\n"},
		dstring&{value:(msg&string)|strings.Join(msg, " ")},
	]
}

header :: [
	"#!/bin/sh",
	"# AUTOGENERATED",
]

script:: {
	_cmds: [...run]
	_flags: *"e" | string
	_debug: *false | bool
	if _debug {
		_flags: "ex"
	}

	compiled: strings.Join(_header + [ c.fragment for c in _cmds ], "\n") + "\n"

	_header = header + ["set -\(_flags)"]
}
